<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>端口敲门（Port Knocking）教程</title>
      <link href="/2025/05/07/knockd/"/>
      <url>/2025/05/07/knockd/</url>
      
        <content type="html"><![CDATA[<h1 id="端口敲门（Port-Knocking）脚本"><a href="#端口敲门（Port-Knocking）脚本" class="headerlink" title="端口敲门（Port Knocking）脚本"></a>端口敲门（Port Knocking）脚本</h1><h2 id="什么是端口敲门？"><a href="#什么是端口敲门？" class="headerlink" title="什么是端口敲门？"></a>什么是端口敲门？</h2><p>端口敲门是一种网络安全技术，通过按特定顺序”敲击”一系列端口，才能打开目标端口的访问权限。这就像是一种密码锁，只有知道正确的”敲门”顺序，才能获得访问权限。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>脚本接受两个主要参数：</p><ul><li><code>-allow</code>：要保护的端口（想要最终访问的端口）</li><li><code>-knowk</code>：敲门端口序列（按顺序敲击的端口）</li></ul><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash knockers.sh -allow 22 -knowk 88,99,33,44</span><br></pre></td></tr></table></figure><p>这个命令表示：</p><ul><li>保护SSH端口（22）</li><li>需要按顺序敲击 88→99→33→44 这四个端口才能获得SSH访问权限</li></ul><h2 id="脚本源码"><a href="#脚本源码" class="headerlink" title="脚本源码"></a>脚本源码</h2><pre><code class="language-bash">#!/usr/bin/env bash##author：wangsendi##url：https://www.yuque.com/wangsendi###端口敲门   __help中使用方法 allow 是要访问的端口  knowk 是敲门端口 依次敲门就行# 默认值_allow=false_knowk=false_allow_values=&quot;&quot;_knowk_values=&quot;&quot;# 解析参数while [[ $# -gt 0 ]]; do    key=&quot;$1&quot;    case $key in    -allow)        _allow=true        shift        _allow_values=&quot;$1&quot;        shift        ;;    -knowk)        _knowk=true        shift        _knowk_values=&quot;$1&quot;        shift        ;;    *)        # 对于未知参数，你可以选择忽略或者给出错误信息        echo &quot;Unknown option: $1&quot;        shift        ;;    esacdone__main() &#123;    # 转换逗号分隔的字符串为数组    mapfile -d , -t _allow_ports &lt; &lt;(echo -n &quot;$_allow_values&quot; | tr -d &#39;\n&#39;)    mapfile -d , -t _knowk_ports &lt; &lt;(echo -n &quot;$_knowk_values&quot; | tr -d &#39;\n&#39;)    # 打印参数值    echo &quot;allow_ports: $&#123;_allow_ports[*]&#125;&quot;    echo &quot;knowk_ports: $&#123;_knowk_ports[*]&#125;&quot;    &#123;        #开始执行的通用rule        nft delete table inet portknock        nft add table inet portknock        # 创建链        nft add chain inet portknock input &#39;&#123; type filter hook input priority -10 ; policy accept ; &#125;&#39;        nft add set inet portknock guarded_ports &#39;&#123; type inet_service; &#125;&#39;        nft add element inet portknock guarded_ports \&#123; &quot;$&#123;_allow_values&#125;&quot; \&#125;        # 定义客户端 IPv4 地址集合        nft add set inet portknock clients_ipv4 &#39;&#123; type ipv4_addr; flags timeout; &#125;&#39;        # 定义客户端 IPv6 地址集合        nft add set inet portknock clients_ipv6 &#39;&#123; type ipv6_addr; flags timeout; &#125;&#39;        # 定义 IPv4 候选者集合        nft add set inet portknock candidates_ipv4 &#39;&#123; type ipv4_addr . inet_service; flags timeout; &#125;&#39;        # 定义 IPv6 候选者集合        nft add set inet portknock candidates_ipv6 &#39;&#123; type ipv6_addr . inet_service; flags timeout; &#125;&#39;        # 定义 input 链        nft add chain inet portknock input &#39;&#123; type filter hook input priority -10; policy accept; &#125;&#39;        # 如果是本地回环接口，则返回        nft add rule inet portknock input iifname &quot;lo&quot; return    &#125;    if [ &quot;$&#123;#_knowk_ports[@]&#125;&quot; -eq 1 ]; then        nft add rule inet portknock input tcp dport &quot;$&#123;_knowk_ports[0]&#125;&quot; add @clients_ipv4 &#39;&#123; ip saddr timeout 10s &#125;&#39; log prefix &#39;&quot;Successful portknock: &quot;&#39;        nft add rule inet portknock input tcp dport &quot;$&#123;_knowk_ports[0]&#125;&quot; add @clients_ipv6 &#39;&#123; ip6 saddr timeout 10s &#125;&#39; log prefix &#39;&quot;Successful portknock: &quot;&#39;    else        for item in $(seq 0 $(($&#123;#_knowk_ports[@]&#125; - 1))); do            case &quot;$&#123;item&#125;&quot; in            0)                nft add rule inet portknock input tcp dport &quot;$&#123;_knowk_ports[$item]&#125;&quot; add @candidates_ipv4 \&#123; ip saddr . &quot;$&#123;_knowk_ports[item + 1]&#125;&quot; timeout 10s \&#125;                nft add rule inet portknock input tcp dport &quot;$&#123;_knowk_ports[$item]&#125;&quot; add @candidates_ipv6 \&#123; ip6 saddr . &quot;$&#123;_knowk_ports[item + 1]&#125;&quot; timeout 10s \&#125;                ;;            &quot;$(($&#123;#_knowk_ports[@]&#125; - 1))&quot;)                nft add rule inet portknock input tcp dport &quot;$&#123;_knowk_ports[$item]&#125;&quot; ip saddr . tcp dport @candidates_ipv4 add @clients_ipv4 &#39;&#123; ip saddr timeout 10s &#125;&#39; log prefix &#39;&quot;Successful portknock: &quot;&#39;                nft add rule inet portknock input tcp dport &quot;$&#123;_knowk_ports[$item]&#125;&quot; ip6 saddr . tcp dport @candidates_ipv6 add @clients_ipv6 &#39;&#123; ip6 saddr timeout 10s &#125;&#39; log prefix &#39;&quot;Successful portknock: &quot;&#39;                ;;            *)                nft add rule inet portknock input tcp dport &quot;$&#123;_knowk_ports[$item]&#125;&quot; ip saddr . tcp dport @candidates_ipv4 add @candidates_ipv4 \&#123; ip saddr . &quot;$&#123;_knowk_ports[item + 1]&#125;&quot; timeout 10s \&#125;                nft add rule inet portknock input tcp dport &quot;$&#123;_knowk_ports[$item]&#125;&quot; ip6 saddr . tcp dport @candidates_ipv6 add @candidates_ipv6 \&#123; ip6 saddr . &quot;$&#123;_knowk_ports[item + 1]&#125;&quot; timeout 10s \&#125;                ;;            esac        done    fi    &#123;        # 保护规则        nft add rule inet portknock input tcp dport @guarded_ports ip saddr @clients_ipv4 counter accept        nft add rule inet portknock input tcp dport @guarded_ports ip6 saddr @clients_ipv6 counter accept        nft add rule inet portknock input tcp dport @guarded_ports ct state established,related counter accept        nft add rule inet portknock input tcp dport @guarded_ports counter reject with tcp reset    &#125;&#125;__main__help() &#123;    bash /apps/data/workspace/default/shell/knockers/knockers.sh -allow 22 -knowk 88,99,33,44&#125;## 工作原理简介1. 脚本创建一个nftables防火墙表和规则集2. 设置受保护的端口（如SSH 22端口）3. 定义&quot;敲门&quot;顺序（如 88→99→33→44）4. 当客户端按正确顺序敲击这些端口时，其IP地址会被临时加入白名单（10秒有效期）5. 白名单内的IP可以访问受保护的端口，其他IP则被拒绝## 实际应用场景此脚本适合用于保护服务器的敏感端口（如SSH）不被随意扫描和暴力破解。即使攻击者知道你的SSH端口，没有正确的&quot;敲门&quot;序列也无法连接。## 优点- 同时支持IPv4和IPv6- 可设置单个或多个敲门端口- 白名单有超时机制，增强安全性- 成功敲门会记录日志</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/02/23/hello-world/"/>
      <url>/2025/02/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hello </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
